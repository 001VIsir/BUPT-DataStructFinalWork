霍夫曼编码压缩程序
该程序实现了霍夫曼编码，这是一种常见的无损数据压缩算法。程序从文本文件中读取输入内容，使用霍夫曼编码进行压缩，将霍夫曼码写入文件，并将压缩的数据存储在二进制文件中。此外，它解码压缩的数据，并将原始文本写入单独的文件以进行验证。

Node结构体
Node结构体表示霍夫曼树中的一个节点。它包含：
char ch：节点中存储的字符。
int freq：字符的频率。
Node* left：指向左子节点的指针。
Node* right：指向右子节点的指针。

getNode 函数
创建具有给定字符、频率和子节点指针的新节点。
函数声明：
Node* getNode(char ch, int freq, Node* left, Node* right);
功能：分配并返回一个新的霍夫曼树节点。
参数：
ch：节点存储的字符。
freq：字符的频率。
left：左子节点。
right：右子节点。

comp结构体
优先队列的比较器，用于根据频率对节点进行排序。
struct comp {
    bool operator()(Node* l, Node* r);
}; 
参数：
l 和 r：需要比较的两个节点。
返回值：true 表示 l 的频率大于 r 的频率。

encode 函数
通过遍历霍夫曼树生成字符的霍夫曼编码。
函数声明：
void encode(Node* root, string str, unordered_map<char, string>& huffmanCode);
参数：
root：霍夫曼树的根节点。
str：当前遍历路径上的编码。
huffmanCode：存储字符及其对应编码的哈希表。
无返回值

decode 函数
使用霍夫曼树将二进制字符串解码回原始文本。
函数声明：
void decode(Node* root, int& index, string str, ofstream& outfile);
功能：递归遍历霍夫曼树，解码二进制字符串。
参数：
root：霍夫曼树的根节点。
index：当前二进制字符串的索引。
str：编码后的二进制字符串。
outfile：输出解码文本的文件流。
无返回值，输出解码后文件

buildHuffmanTree函数
构建霍夫曼树，生成霍夫曼编码，压缩文本，将压缩数据和霍夫曼编码写入文件，并解码压缩数据以验证压缩过程。
void buildHuffmanTree(string text);
功能：实现霍夫曼编码的主要逻辑，包含构建霍夫曼树、生成编码、压缩文本、写入文件和解码验证。
参数：
text：输入的原始文本。

算法介绍：
Node结构体
Node 结构体用于构建霍夫曼树。每个节点表示一个字符及其在文本中的频率。left 和 right 指针用于连接树中的节点。

getNode 函数
该函数分配一个新节点，并使用指定的字符、频率和子节点进行初始化，然后返回该节点的指针。

comp 结构体
此比较器由优先队列使用，以按频率升序对节点进行排序。频率最小的节点优先级最高。

encode 函数
encode 函数通过递归方法遍历霍夫曼树以生成每个字符的编码：
如果节点是叶节点（无子节点），则将当前霍夫曼编码分配给该字符。
否则，向左子节点追加 '0'，向右子节点追加 '1'，并递归编码子节点。

decode 函数
decode 函数通过遍历霍夫曼树将压缩的二进制字符串解码回原始文本：
从根节点开始，遇到 '0' 向左移动，遇到 '1' 向右移动，直到到达叶节点，此时将字符写入输出文件。
通过递增索引处理二进制字符串中的下一个位。

buildHuffmanTree 函数
此函数处理霍夫曼编码的整个过程：
频率计算：计算文本中每个字符的频率。
树构建：使用优先队列通过合并频率最小的两个节点构建霍夫曼树，直到只剩一个节点。
编码生成：调用 encode 为每个字符生成霍夫曼编码。
压缩：用对应的霍夫曼编码替换文本中的每个字符，创建压缩的二进制字符串。
文件写入：
   将霍夫曼编码写入 huffman_codes.txt。
   将二进制字符串转换为二进制表示并写入 compressed_data.bin。
解码：将压缩的二进制字符串解码回原始文本，并写入 decoded_text.txt 以进行验证。

输出文件

huffman_codes.txt：包含每个字符的霍夫曼编码。
compressed_data.bin：包含压缩的二进制数据。
decoded_text.txt：包含解压缩的文本，应该与原始输入文本匹配。

相关依赖：
C++ 标准库：包括 <iostream>、<fstream>、<vector>、<queue>、<unordered_map>、<string> 和 <bitset> 头文件。

错误处理
程序假设输入文件存在且可读。为了增强健壮性，应添加文件操作的错误处理（例如，检查文件是否打开）。
